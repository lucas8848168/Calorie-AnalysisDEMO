# 智能拦截功能

## 🎯 功能说明

当本地模型检测到非食物图片且置信度 ≥ 65% 时：
- **首次上传**：直接拦截，不调用云端 API（节省成本）
- **二次上传**：允许通过，调用云端 API（尊重用户判断）

## ✨ 三级拦截策略

### 级别 1：直接拦截（置信度 ≥ 65%）
**首次上传时：**
```
识别为：电视
置信度：85%
结果：🛑 直接拦截，不调用 API
提示：如果您确定这是食物图片，请重新上传以继续分析
```

**二次上传时：**
```
识别为：电视
置信度：85%
结果：⚠️ 显示警告，但允许继续
提示：您已重新上传，将继续使用云端 AI 分析
```

### 级别 2：警告但继续（置信度 60-65%）
```
识别为：笔记本电脑
置信度：62%
结果：⚠️ 显示警告，允许继续
提示：这可能不是食物图片，将继续使用云端 AI 分析
```

### 级别 3：放行（置信度 < 60%）
```
识别为：未知
置信度：30%
结果：✅ 直接放行，无警告
```

## 📊 决策流程图

```
用户上传图片
    ↓
本地 MobileNet 检测
    ↓
非食物 && 置信度 ≥ 65%？
    ├─ 是 → 是首次上传？
    │       ├─ 是 → 🛑 直接拦截
    │       │       提示：重新上传可继续
    │       │       记录图片 hash
    │       └─ 否 → ⚠️ 警告 + 继续
    │               清除 hash 记录
    │               调用云端 API
    └─ 否 → 非食物 && 置信度 60-65%？
            ├─ 是 → ⚠️ 警告 + 继续
            └─ 否 → ✅ 直接放行
```

## 🧪 测试场景

### 场景 1：电视机（置信度 85%）

**首次上传：**
```
步骤 1: 图片压缩 ✅
步骤 2: 本地检测 ✅
  - 识别为：电视
  - 置信度：85%
  - 判断：非食物 && 85% ≥ 65%
  - 结果：🛑 直接拦截

错误页面显示：
  ⚠️
  分析失败
  🚫 这张图片不是食物图片（识别为电视，置信度85%）。
  
  如果您确定这是食物图片，请重新上传以继续分析。
  
  [重新上传]
```

**二次上传（相同图片）：**
```
步骤 1: 图片压缩 ✅
步骤 2: 本地检测 ✅
  - 识别为：电视
  - 置信度：85%
  - 判断：非食物 && 85% ≥ 65% && 是重复上传
  - 结果：⚠️ 警告 + 继续

警告显示：
  ⚠️ 本地模型检测：这可能不是食物图片
  识别为：电视
  置信度：85%
  您已重新上传，将继续使用云端 AI 分析。

步骤 3: 检查缓存 ✅
步骤 4: 云端 AI 分析 ✅
  - 豆包返回：NOT_FOOD
  - 显示错误页面
```

### 场景 2：笔记本电脑（置信度 62%）

**首次上传：**
```
步骤 1: 图片压缩 ✅
步骤 2: 本地检测 ✅
  - 识别为：笔记本电脑
  - 置信度：62%
  - 判断：非食物 && 62% < 65%
  - 结果：⚠️ 警告 + 继续

警告显示：
  ⚠️ 本地模型检测：这可能不是食物图片
  识别为：笔记本电脑
  置信度：62%
  将继续使用云端 AI 分析...

步骤 3-4: 继续分析 ✅
```

### 场景 3：模糊图片（置信度 30%）

**首次上传：**
```
步骤 1: 图片压缩 ✅
步骤 2: 本地检测 ✅
  - 识别为：未知
  - 置信度：30%
  - 判断：置信度不足
  - 结果：✅ 直接放行

无警告
步骤 3-4: 继续分析 ✅
```

### 场景 4：食物图片（置信度 78%）

**首次上传：**
```
步骤 1: 图片压缩 ✅
步骤 2: 本地检测 ✅
  - 识别为：pizza
  - 置信度：78%
  - 判断：是食物
  - 结果：✅ 直接放行

无警告
步骤 3-4: 继续分析 ✅
```

## 🔧 技术实现

### 1. 图片 Hash 计算
```typescript
async function computeSimpleHash(str: string): Promise<string> {
  // 取前 1000 个字符计算 hash
  const sample = str.substring(0, 1000);
  const encoder = new TextEncoder();
  const data = encoder.encode(sample);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  return hashArray.map(b => b.toString(16).padStart(2, '0')).join('').substring(0, 16);
}
```

### 2. 状态管理
```typescript
interface ImageProcessorState {
  // ...
  lastBlockedImageHash?: string; // 记录上次被拦截的图片 hash
}
```

### 3. 拦截逻辑
```typescript
const shouldBlock = !detection.isFood && topPrediction && topPrediction.probability >= 0.65;
const isRetry = state.lastBlockedImageHash === imageHash;

if (shouldBlock && !isRetry) {
  // 首次上传：拦截
  setState({ lastBlockedImageHash: imageHash });
  throw new Error(...);
}

if (shouldBlock && isRetry) {
  // 二次上传：允许通过
  setState({ lastBlockedImageHash: undefined });
  // 继续处理...
}
```

## 💰 成本优化

### API 调用节省

**场景：用户误传非食物图片**

#### 无拦截（原方案）
```
用户上传电视机照片
  ↓
本地检测：警告
  ↓
云端 API 调用 ✅ （消耗 tokens）
  ↓
返回 NOT_FOOD
```
**成本**：每次都调用 API

#### 有拦截（新方案）
```
用户上传电视机照片
  ↓
本地检测：拦截 🛑
  ↓
不调用 API ❌ （节省 tokens）
  ↓
直接返回错误
```
**成本**：首次不调用 API，节省 100%

### 预期节省

假设：
- 10% 的上传是明显非食物（置信度 ≥ 65%）
- 其中 80% 的用户看到拦截后不会重新上传

**节省率**：10% × 80% = **8% API 调用**

## 🎯 用户体验

### 优点
1. **快速反馈**：明显非食物立即拦截，无需等待 API
2. **尊重用户**：允许二次上传，用户有最终决定权
3. **清晰提示**：告知用户为什么被拦截，如何继续

### 缺点
1. **可能误判**：本地模型可能错误拦截食物图片
2. **需要重传**：用户需要重新上传才能继续

### 平衡策略
- 阈值设置为 65%（较高），减少误判
- 允许二次上传，给用户纠正机会
- 60-65% 只警告不拦截，保持灵活性

## 📝 修改文件

1. ✅ `src/hooks/useImageProcessor.ts`
   - 添加 `computeSimpleHash` 函数
   - 添加 `lastBlockedImageHash` 状态
   - 实现三级拦截逻辑

2. ✅ `SMART_BLOCKING_FEATURE.md`
   - 功能说明文档（本文件）

## 🔍 调试日志

### 首次上传（拦截）
```
🤖 步骤 2/4: 本地 AI 检测...
📊 本地检测结果: { isFood: false, confidence: 0.85, ... }
🛑 本地拦截（置信度 ≥ 65%）: 这张图片不是食物图片...
❌ 图片处理失败: Error: ...
```

### 二次上传（通过）
```
🤖 步骤 2/4: 本地 AI 检测...
📊 本地检测结果: { isFood: false, confidence: 0.85, ... }
⚠️ 二次上传，允许通过: 您已重新上传，将继续使用云端 AI 分析
💾 步骤 3/4: 检查缓存...
☁️ 步骤 4/4: 云端 AI 分析...
```

## 🎨 UI 改进建议

### 错误页面（首次拦截）
```
⚠️
本地检测拦截

🚫 这张图片不是食物图片（识别为电视，置信度85%）。

💡 如果您确定这是食物图片，请重新上传以继续分析。

[重新上传]  [取消]
```

### 警告消息（二次上传）
```
⚠️ 本地模型检测警告

识别为：电视
置信度：85%

您已重新上传，将继续使用云端 AI 分析。
```

---

**功能完成时间**：2025-11-24  
**状态**：✅ 已实现  
**测试**：刷新页面后上传电视机照片验证
